= BuildQueue =

BuildQueue class represents the run-time-records of builds being
processed.

See buildd-queuebuilder.txt for more information about the BuildQueue
initialization.

BuildQueue should provide all the information needed for dispatching
and collecting build results.

As soon as a build job is processed succesfully (dispatched &
collected) the BuildQueue record representing it is removed.

    >>> from lp.testing import verifyObject
    >>> from lp.services.propertycache import get_property_cache
    >>> from lp.buildmaster.interfaces.buildqueue import (
    ...     IBuildQueue, IBuildQueueSet)

Get an instance of Builder from the current sampledata using the
IBuildQueueSet zope utility. The zope utility itself will be
documented later on this document, we are only using it to retrive an
IBuildQueue record with the security proxies in place:

    >>> bq = getUtility(IBuildQueueSet).get(1)

Instances returned by IBuildQueueSet provides the IBuildQueue interface:

    >>> verifyObject(IBuildQueue, bq)
    True

The IBuild record related to this job is provided by the 'build'
attribute:

    >>> from lp.soyuz.interfaces.binarypackagebuild import IBinaryPackageBuildSet
    >>> build = getUtility(IBinaryPackageBuildSet).getByQueueEntry(bq)
    >>> build.id
    8
    >>> build.status.name
    'BUILDING'

The static timestamps, representing when the record was initialized
(inserted) and when the job was dispatched are provided as datetime
instances:

    >>> bq.job.date_created
    datetime.datetime(2005, 6, 15, 9, 14, 12, 820778, tzinfo=<UTC>)

    >>> bq.date_started
    datetime.datetime(2005, 6, 15, 9, 20, 12, 820778, tzinfo=<UTC>)

Check Builder foreign key, which indicated which builder 'is processing'
the job in question:

The 'builder' attribute provides the IBuilder instance of the builder
currently processing this job:

    >>> bq.builder.name
    u'bob'

'logtail' is a text field which stores up to 1 Kbyte of the last
logged actions during the build process, it is updated according to the
frequency set in buildd-slavescanner, normally 10 seconds, see
buildd-slavescanner.txt for further information:

    >>> bq.logtail
    u'Dummy sampledata entry, not processing'

'lastscore' is the heuristic index generated by queuebuilder to order
the dispatching process, see more information in
buildd-queuebuilder.txt:

    >>> bq.lastscore
    1

'manual' is a boolean, which is meant to suppress the auto-scoring
procedure, i.e., when it is set the job do not get re-scored, it is
used to manually reorder jobs via the web UI:

    >>> bq.manual
    False

BuildQueue provides a method to handle "manual scoring" procedure
properly, in order to retain the manually set score we need to
set 'manual' attribute atomically. For this we use manualScore:

    >>> pending_bq = getUtility(IBuildQueueSet).get(2)

    >>> pending_bq.manual, pending_bq.lastscore
    (False, 10)
    >>> pending_bq.manualScore(1000)

    >>> pending_bq.manual, pending_bq.lastscore
    (True, 1000)


== Dispatching and Reseting jobs ==

The sampledata contains an active job, being built by the 'bob'
builder.

    >>> from lp.buildmaster.interfaces.builder import IBuilderSet

    >>> bob = getUtility(IBuilderSet)['bob']
    >>> job = bob.currentjob

    >>> print job.builder.name
    bob
    >>> job.date_started is not None
    True
    >>> print job.logtail
    Dummy sampledata entry, not processing
    >>> build = getUtility(IBinaryPackageBuildSet).getByQueueEntry(job)
    >>> print build.status.name
    BUILDING
    >>> print job.lastscore
    1

IBuildQueue.reset() will reset the job, enabling it to be dispatched
to another build. The score value of the job is preserved.

    >>> job.reset()

    >>> del get_property_cache(bob).currentjob
    >>> print bob.currentjob
    None

    >>> print job.builder
    None
    >>> print job.date_started
    None
    >>> print job.logtail
    None
    >>> print build.status.name
    NEEDSBUILD
    >>> print job.lastscore
    1

On the flip-side, IBuildQueue.markAsBuilding() will assign the job to
the specified builder.

    >>> job.markAsBuilding(bob)

    >>> del get_property_cache(bob).currentjob
    >>> bob.currentjob == job
    True

    >>> print job.builder.name
    bob
    >>> job.date_started is not None
    True
    >>> print build.status.name
    BUILDING


== BuildQueueSet utility ==

Now perform the tests for the BuildQueue zope utility, BuildQueueSet.
Check if the instance returned as utility corresponds to its
respective interface:

    >>> bqset = getUtility(IBuildQueueSet)
    >>> verifyObject(IBuildQueueSet, bqset)
    True

IBuildQueueSet utility provides a 'get' method:

    >>> bqset.get(2).id
    2

Another method to fetch the BuildQueue being processed for a builder,
there should be only one since the builders are sigle-task
applications:

    >>> current_job = bqset.getByBuilder(bob)
    >>> print current_job.builder.name
    bob
